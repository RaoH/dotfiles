#!/usr/bin/env bash

# Dynamically detect WiFi interface (works across different machines)
WIFI_DEVICE=$(networksetup -listallhardwareports | awk '/Wi-Fi|AirPort/{getline; print $2}')

# Dynamically detect active Ethernet interface (one with an IP address)
ETHERNET_DEVICE=$(networksetup -listallhardwareports | awk '/^Hardware Port: Ethernet/{getline; print $2}' | while read iface; do
    if ifconfig "$iface" 2>/dev/null | grep -q "inet "; then
        echo "$iface"
        break
    fi
done)

# Check WiFi status
WIFI_CONNECTED=false
WIFI_IP=""
if [[ -n "$WIFI_DEVICE" ]]; then
    # Try to get SSID from networksetup first
    WIFI_STATUS=$(networksetup -getairportnetwork "$WIFI_DEVICE" 2>/dev/null | grep -v "You are not associated with an AirPort network")
    WIFI_SSID=$(echo "$WIFI_STATUS" | sed 's/Current Wi-Fi Network: //')
    
    # Get WiFi IP address and status
    WIFI_IP=$(ifconfig "$WIFI_DEVICE" 2>/dev/null | grep "inet " | awk '{print $2}')
    WIFI_STATUS_LINE=$(ifconfig "$WIFI_DEVICE" 2>/dev/null | grep "status:" | awk '{print $2}')
    
    # Check if WiFi is actually connected
    if [[ -n "$WIFI_SSID" && "$WIFI_SSID" != "" ]]; then
        WIFI_CONNECTED=true
    elif [[ -n "$WIFI_IP" && "$WIFI_STATUS_LINE" == "active" ]]; then
        # WiFi is connected but SSID can't be retrieved via networksetup
        # Try using CoreWLAN framework via Swift (works on macOS 15+)
        WIFI_SSID=$(swift -framework CoreWLAN - <<'SWIFT' 2>/dev/null
import CoreWLAN
if let interface = CWWiFiClient.shared().interface(),
   let profiles = interface.configuration()?.networkProfiles,
   let firstProfile = profiles.firstObject as? CWNetworkProfile,
   let ssid = firstProfile.ssid, !ssid.isEmpty {
    print(ssid)
}
SWIFT
        )
        
        # If Swift retrieval worked, use it; otherwise fall back to IP
        if [[ -n "$WIFI_SSID" && "$WIFI_SSID" != "" ]]; then
            WIFI_CONNECTED=true
        else
            WIFI_CONNECTED=true
            WIFI_SSID="$WIFI_IP"  # Show IP as last resort
        fi
    fi
fi

# Check Ethernet status
ETHERNET_CONNECTED=false
ETHERNET_IP=""
if [[ -n "$ETHERNET_DEVICE" ]]; then
    ETHERNET_IP=$(ifconfig "$ETHERNET_DEVICE" 2>/dev/null | grep "inet " | awk '{print $2}')
    if [[ -n "$ETHERNET_IP" ]]; then
        ETHERNET_CONNECTED=true
    fi
fi

# Determine connection type and label based on what's connected
if [[ "$WIFI_CONNECTED" == true && "$ETHERNET_CONNECTED" == true ]]; then
    # Both WiFi and Ethernet are connected
    LABEL="Network Connected"
elif [[ "$WIFI_CONNECTED" == true ]]; then
    # Only WiFi connected
    LABEL="WiFi: $WIFI_SSID"
elif [[ "$ETHERNET_CONNECTED" == true ]]; then
    # Only Ethernet connected
    LABEL="Ethernet: $ETHERNET_IP"
else
    # No connection
    LABEL="Disconnected"
fi

# Update the main network item
sketchybar --set "$NAME" \
                 label="$LABEL"

# Handle mouse events for showing IP address on hover
if [[ "$SENDER" == "mouse.entered" ]]; then
    # Show appropriate details based on connection state
    if [[ "$WIFI_CONNECTED" == true && "$ETHERNET_CONNECTED" == true ]]; then
        # Both connected - show both networks and IPs
        sketchybar --set "$NAME" label="WiFi: $WIFI_SSID ($WIFI_IP) | Ethernet: $ETHERNET_IP"
    elif [[ "$WIFI_CONNECTED" == true && -n "$WIFI_IP" ]]; then
        # Only WiFi - show IP
        sketchybar --set "$NAME" label="IP: $WIFI_IP"
    elif [[ "$ETHERNET_CONNECTED" == true ]]; then
        # Only Ethernet - show IP
        sketchybar --set "$NAME" label="IP: $ETHERNET_IP"
    fi
elif [[ "$SENDER" == "mouse.exited" ]]; then
    # Restore original label when not hovering
    sketchybar --set "$NAME" label="$LABEL"
fi